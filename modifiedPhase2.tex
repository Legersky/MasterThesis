

In this section, we introduce algorithms based on the theorems proven in Chapter~\ref{chap:convergence}. We recall an algorithm for checking convergence of Phase 2 for $bb\dots b$ inputs.Next, we show that it is possible to make Phase 2 stable by wrapping the choice of a set of possible weight coefficients into a simple while loop. Finally, we present an algorithm for Phase~2 which includes all modifications -- the menshioned check for $bb\dots b$ inputs and control of convergence by searching for an infinite walk in Rauzy graph $G_k$.

\subsection*{Checking $bb\dots b$ inputs}

Algorithm~\ref{alg:oneletterSets} was proposed in \cite{vu}. It checks whether Phase~2 stops when it processes input digits $bb\dots b$.
Sets $\Qb{m}$  can be easily constructed separately for each $b\in\B$ for given $m$. We build the set $\Qb{m}$ for input digits $bb\dots b$ in the same way as in Phase 2. This means that we first search for $\Qb{1}$ such that 
$$
b + \Q \subset \A + \beta \Qb{1}\,.
$$
Until the set $\Qb{m}$ contains only one element, we increment the length of  window $m$ and, using Algorithm \ref{alg:possibleWeightCoefSetStable}, we find a subset $\Qb{m+1}$ of the set $\Qb{m}$ such that
$$
b + \Qb{m} \subset \A + \beta \Qb{m+1}\,.
$$
In each iteration, we check whether the set $\Qb{m+1}$ is strictly smaller than the set $\Qb{m}$. If not, we know by Theorem \ref{thm:bbbCondition} that Phase 2 does not converge because $\#\Qb{m}$ is eventually a constant greater than 2.

Hence, non-finiteness of Phase~2 can be revealed by running Algorithm \ref{alg:oneletterSets} for each input digit $b\in\B$.
\begin{algorithm}
  \caption{Check the input $bb\dots b$}
    \label{alg:oneletterSets}
  \begin{algorithmic}[1]
    \REQUIRE{Weight coefficient set $\Q$, digit $b\in\B$}
    \ENSURE{TRUE if there is a unique weight coefficient for input $bb\dots b$, FALSE otherwise}
    \STATE Find minimal set $\Qb{1} \subset \Q$ such that
      $$
      b + \Q \subset \A + \beta \Qb{1}\,.
      $$
      \vspace{-20pt}
    \STATE $m:=1$
    \WHILE{$\#\Qb{m} > 1$}
        \STATE $m:= m +1$
        \STATE By Algorithm \ref{alg:possibleWeightCoefSetStable}, find minimal set $\Qb{m} \subset \Qb{m-1}$ such that
          $$
          b + \Qb{m-1} \subset \A + \beta \Qb{m}\,.
          $$  
          \vspace{-20pt}
        \IF{$\#\Qb{m}=\#\Qb{m-1}$}
            \RETURN FALSE
        \ENDIF
    \ENDWHILE  
    \RETURN TRUE
  \end{algorithmic}
\end{algorithm}


\subsection*{Stable Phase 2}
We remind that for checking whether Phase 2 converges we assume that it is stable. An algorithm of choice of possible weight coefficients set can be easily modified to ensure that 
$$\Qw{1}{k}=\Qw{1}{(k-1)} \implies \Qwo{k}=\Qwo{(k-1)}$$
for all $\tuple{1}{k}\in\B^k$. If the algorithm is deterministic, then the set $\Qwo{k}$ is determined by the set $\Qw{1}{k}$, $\Qwo{(k-1)}$ and $w_0$. Similarly, the set $\Qwo{(k-1)}$ is determined by  the set $\Qw{1}{(k-1)}$, $\Qwo{(k-2)}$ and $w_0$.

\begin{algorithm}
  \caption{Stable search for possible weight coefficient set $\Qwo{k}$}
    \label{alg:possibleWeightCoefSetStable}
  \begin{algorithmic}[1]
    \REQUIRE{Input digit $w_0$, set of possible carries $\Qw{1}{k}$, previous set of possible weight coefficients $\Qwo{(k-1)}$}
	\STATE $\Q'_w:=\Qwo{(k-1)}$
	\WHILE{TRUE}
		\STATE By Algorithm \ref{alg:minimalSet}, find the set of possible weight coefficients  $\Qwo{k}$ as a subset of $\Q'_w$ instead of the previous set of weight coefficients $\Qwo{(k-1)}$.
		\IF{$\Qwo{k}=\Q'_w$}
			\RETURN $\Qwo{k}$
		\ENDIF
		\STATE $\Q'_w:=\Qwo{k}$
	\ENDWHILE
  \end{algorithmic}
\end{algorithm}


\begin{algorithm}
  \caption{Modified search for a weight function (Phase 2)}
    \label{alg:weightFunction_modified}
  \begin{algorithmic}[1]
    \REQUIRE{weight coefficients set $\Q$}
    \FORALL{$b\in\B$}
    	\IF  {\NOT Check the input $bb\dots b$ by Algorithm \ref{alg:oneletterSets}}
    		\RETURN Phase 2 does not converge for input $bb\dots b$.
    	\ENDIF
    \ENDFOR
    \FORALL{$w_0 \in \B$} 
        \STATE By Algorithm~\ref{alg:minimalSet}, find set $\Q_{[w_0]} \subset \Q$ such that
          $$
          w_0 + \Q \subset \A + \beta \Q_{[w_0]}
          $$\vspace{-20pt}
    \ENDFOR
    \STATE $k:=0$
    %\STATE $G_0:=$ empty graph
    \WHILE{$\max\{\#\Qwo{k}:\tupleo{k} \in \B^{k+1} \} > 1$}
        \STATE $k:= k +1$
        \FORALL{$\tupleo{k} \in \B^{k+1}$}
            \STATE By Algorithm~\ref{alg:possibleWeightCoefSetStable}, find set $\Qwo{k} \subset \Qwo{(k-1)}$ such that
              $$
              w_j + \Qw{1}{k} \subset \A + \beta \Qwo{k}\,.
              $$\vspace{-20pt}
              \IF {$\Qwo{k} = \Qwo{(k-1)}$ \AND $k\geq 2$}
              	\STATE Add the vertex $\tupleo{k}$ to the Rauzy graph $G_{k+1}$.
              	\IF{Check infinite walks in $G_k$ starting in $\tuple{1}{k}$ by Alg.~\ref{alg:checkCycles}}
              		\RETURN Phase 2 does not converge.
              	\ENDIF
              \ENDIF
     %    	\STATE $G_{k}:=G_{k+1}$
        \ENDFOR  
    \ENDWHILE  
    \STATE $r:= k$ 
    \FORALL{$\tupleo{r} \in \B^{r+1}$}  
        \STATE $q\tupleo{r}:=$ only element of $\Qwo{r}$
    \ENDFOR
    \RETURN $q$
  \end{algorithmic}
\end{algorithm}



\begin{algorithm}
  \caption{Check if there is in an infinite walk in $G_k$ starting in $\tuple{1}{k}$}
    \label{alg:checkCycles}
  \begin{algorithmic}[1]
    \REQUIRE{Rauzy graph $G_k$, combination of input digits $\tuple{1}{k}$}
    \ENSURE{Return TRUE if TRUE is returned in any step of the recursion, that is when a walk $w_1, w_2, \dots$ enters an oriented cycle in $G_k$. Otherwise return FALSE.}
	\IF {$\tuple{1}{k}\in G_k$}
		\STATE By Algorithm~\ref{alg:enterVertices}, enter next vertices from $\tuple{1}{k}$ with the traversed walk  $\tuple{1}{k}$.
	\ELSE
		\RETURN FALSE
	\ENDIF
	\RETURN FALSE
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Enter vertices from $\tuple[w']{1}{k}$}
    \label{alg:enterVertices}
  \begin{algorithmic}[1]
  	\REQUIRE{Rauzy graph $G_k$, vertex $\tuple[w']{1}{k}$, traversed walk $(w_1, \dots, w_l)$.}
	\FORALL {$w'_{k+1}\in \B$ such that $\tuple[w']{1}{k}\rightarrow \tuple[w']{2}{(k+1)}\in G_k$}
		\IF {$\tuple[w']{2}{(k+1)}$ is in the traversed walk $(w_1, \dots, w_l)$}
			\RETURN TRUE
		\ELSE
			\STATE By Algorithm~\ref{alg:enterVertices}, enter next vertices from $\tuple[w']{2}{(k+1)}$ with the traversed walk   $(w_1, \dots, w_l, w'_{(k+1)})$.
		\ENDIF
	\ENDFOR
  \end{algorithmic}
\end{algorithm}



